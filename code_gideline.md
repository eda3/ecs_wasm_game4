# Rustコードガイドライン

## コーディングスタイル
- 変数と関数名はスネークケース（`snake_case`）を使用する
- 構造体、列挙型、トレイト名はキャメルケース（`CamelCase`）を使用する
- インデントは4スペースを使用する
- ファイル名はスネークケース（`snake_case.rs`）を使用する
- コードの各セクションにはドキュメントコメント（`///`）を使用する
- 複雑な処理は通常のコメント（`//`）で説明する
- 各処理ステップに番号付きコメント（`// 1.`, `// 2.` など）を使うと読みやすくなる

## エラー処理
- 関数は適切な場合に`Result<T, E>`を返す
- パニックの代わりに`Result`を使用する
- Web APIとのやり取りでは`JsValue`をエラー型として使用する
- 不要な`unwrap()`や`expect()`の使用は避ける
- リソースマネージャーから取得したOptional型の値は、使用前に`unwrap()`または適切なパターンマッチングを行う

## 借用と所有権
- 不必要なクローンを避け、可能な限り参照を使用する
- 複数のコンポーネントを同時に変更する場合は、借用の問題を避けるため以下の手順を守る：
  1. 必要なデータをすべて先に取得する
  2. 取得したデータを利用して処理を行う
  3. 結果をコンポーネントに適用する
- スコープブロック（`{}`）を使って借用の寿命を制限する
- 所有権の移動に注意し、必要に応じて参照を使用する
- 可変参照（`&mut T`）と不変参照（`&T`）を同時に持つことはできないことを常に意識する
- あるエンティティの複数のコンポーネントに対する可変参照を同時に持つことはできないことを常に意識する

### 借用問題解決の具体例

#### 不正な例（借用エラー）:
```rust
// エラー: `world`の可変借用中に不変借用が発生する
if let Some(draggable) = world.get_component_mut::<Draggable>(entity_id) {
    // ここで`world`の可変借用が発生
    if let Some(transform) = world.get_component::<Transform>(entity_id) {
        // ここで`world`の不変借用が発生（エラー！）
        draggable.original_position = transform.position;
    }
}
```

#### 正しい例（先に必要なデータを取得）:
```rust
// 1. 先に必要なデータを取得
let transform_position;
{
    if let Some(transform) = world.get_component::<Transform>(entity_id) {
        transform_position = transform.position;
    } else {
        return;
    }
}

// 2. 取得したデータを使用して更新
if let Some(draggable) = world.get_component_mut::<Draggable>(entity_id) {
    draggable.original_position = transform_position;
}
```

## 型安全
- 明示的な型アノテーションを使い、型推論に過度に依存しない
- 適切な場合は型パラメータ（ジェネリクス）を使用する
- `Option<T>`を使用して、値が存在しない可能性を表現する
- 型変換は明示的に行い、安全でない型変換は避ける

## モジュール構成
- 関連する機能は同じモジュールにまとめる
- パブリックインターフェースは明確に定義し、必要なもののみ公開する
- モジュールは論理的に整理し、適切な粒度で分割する

## ECSパターン
- コンポーネントはデータのみを含み、メソッドを最小限に抑える
- システムはロジックを実装し、コンポーネントを操作する
- エンティティは単なるIDで、コンポーネントの集合を表す
- リソースは共有データを管理するために使用する
- コンポーネントには適切な初期化メソッド（`new`、`with_*`など）を提供する

## データフロー設計
- 複雑な処理では、処理の流れを以下のように分割する：
  1. 入力データの収集と検証
  2. 必要な計算の実行
  3. 結果の適用と状態の更新
- 副作用を明確にし、関数の責任範囲を限定する

## 非同期処理
- `wasm_bindgen`を使用してJavaScript関数を安全に呼び出す
- Promiseベースの処理では適切なコールバックを使用する
- 非同期処理の結果を適切に扱い、エラーを処理する

## WebAssemblyの最適化
- 不必要なメモリ割り当てを避ける
- パフォーマンスクリティカルな部分ではVec操作の最適化を考慮する
- 大きなデータ構造の不必要なコピーを避ける
- 重い計算や反復処理はWebAssemblyで行い、DOM操作はJavaScriptに委任する 