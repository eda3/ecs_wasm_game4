# Rustコードガイドライン

## コーディングスタイル
- 変数と関数名はスネークケース（`snake_case`）を使用する
- 構造体、列挙型、トレイト名はキャメルケース（`CamelCase`）を使用する
- インデントは4スペースを使用する
- ファイル名はスネークケース（`snake_case.rs`）を使用する
- コードの各セクションにはドキュメントコメント（`///`）を使用する
- 複雑な処理は通常のコメント（`//`）で説明する
- 各処理ステップに番号付きコメント（`// 1.`, `// 2.` など）を使うと読みやすくなる

## エラー処理
- 関数は適切な場合に`Result<T, E>`を返す
- パニックの代わりに`Result`を使用する
- Web APIとのやり取りでは`JsValue`をエラー型として使用する
- 不要な`unwrap()`や`expect()`の使用は避ける
- リソースマネージャーから取得したOptional型の値は、使用前に`unwrap()`または適切なパターンマッチングを行う

## 借用と所有権
- 不必要なクローンを避け、可能な限り参照を使用する
- 複数のコンポーネントを同時に変更する場合は、借用の問題を避けるため以下の手順を守る：
  1. 必要なデータをすべて先に取得する
  2. 取得したデータを利用して処理を行う
  3. 結果をコンポーネントに適用する
- スコープブロック（`{}`）を使って借用の寿命を制限する
- 所有権の移動に注意し、必要に応じて参照を使用する
- 可変参照（`&mut T`）と不変参照（`&T`）を同時に持つことはできないことを常に意識する
- あるエンティティの複数のコンポーネントに対する可変参照を同時に持つことはできないことを常に意識する

### 借用問題解決の具体例

#### 不正な例（借用エラー）:
```rust
// エラー: `world`の可変借用中に不変借用が発生する
if let Some(draggable) = world.get_component_mut::<Draggable>(entity_id) {
    // ここで`world`の可変借用が発生
    if let Some(transform) = world.get_component::<Transform>(entity_id) {
        // ここで`world`の不変借用が発生（エラー！）
        draggable.original_position = transform.position;
    }
}
```

#### 正しい例（先に必要なデータを取得）:
```rust
// 1. 先に必要なデータを取得
let transform_position;
{
    if let Some(transform) = world.get_component::<Transform>(entity_id) {
        transform_position = transform.position;
    } else {
        return;
    }
}

// 2. 取得したデータを使用して更新
if let Some(draggable) = world.get_component_mut::<Draggable>(entity_id) {
    draggable.original_position = transform_position;
}
```

## 型安全
- 明示的な型アノテーションを使い、型推論に過度に依存しない
- 適切な場合は型パラメータ（ジェネリクス）を使用する
- `Option<T>`を使用して、値が存在しない可能性を表現する
- 型変換は明示的に行い、安全でない型変換は避ける
- 型の不一致がある場合は、適切な変換関数(`as`, `from`, など)を使用して明示的に変換する
- 列挙型の値の比較では、型の互換性を確保するために明示的に変換する（例: `suit as u8`）

## モジュール構成
- 関連する機能は同じモジュールにまとめる
- パブリックインターフェースは明確に定義し、必要なもののみ公開する
- モジュールは論理的に整理し、適切な粒度で分割する

## ECSパターン
- コンポーネントはデータのみを含み、メソッドを最小限に抑える
- システムはロジックを実装し、コンポーネントを操作する
- エンティティは単なるIDで、コンポーネントの集合を表す
- リソースは共有データを管理するために使用する
- コンポーネントには適切な初期化メソッド（`new`、`with_*`など）を提供する

### コンポーネント設計の注意点
- `StackContainer`などの複雑なコンポーネントには以下の命名規則に従ったメソッドを提供する:
  - `get_*` - コンポーネント内の値を取得する読み取り専用メソッド
  - `remove_*` - コンポーネントから要素を削除するメソッド
  - `add_*` - コンポーネントに要素を追加するメソッド
  - `clear_*` - コンポーネント内の特定の要素群をクリアするメソッド
  - `contains_*` - コンポーネント内に特定の要素が含まれているかを確認するメソッド
- コンポーネントを操作するコードで、複数の機能を組み合わせて使用する場合は、一貫した命名規則を使用する
- 同じ機能を提供するメソッドに別名を提供する場合は、ドキュメントコメントで明確に示す（例: `top_card()`と`get_top_card()`）

## データフロー設計
- 複雑な処理では、処理の流れを以下のように分割する：
  1. 入力データの収集と検証
  2. 必要な計算の実行
  3. 結果の適用と状態の更新
- 副作用を明確にし、関数の責任範囲を限定する

## 非同期処理
- `wasm_bindgen`を使用してJavaScript関数を安全に呼び出す
- Promiseベースの処理では適切なコールバックを使用する
- 非同期処理の結果を適切に扱い、エラーを処理する

## WebAssemblyの最適化
- 不必要なメモリ割り当てを避ける
- パフォーマンスクリティカルな部分ではVec操作の最適化を考慮する
- 大きなデータ構造の不必要なコピーを避ける
- 重い計算や反復処理はWebAssemblyで行い、DOM操作はJavaScriptに委任する 